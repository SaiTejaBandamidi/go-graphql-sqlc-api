package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/SaiTejaBandamidi/go-graphql-sqlc-api/db"
	"github.com/SaiTejaBandamidi/go-graphql-sqlc-api/graph/model"
)

// CreateHouse implements MutationResolver.
func (r *mutationResolver) CreateHouse(ctx context.Context, name string, headOfHouse *string) (*model.House, error) {
	// Parse the name into first name and last name
	firstName := name
	lastName := "House"

	// Convert *string to sql.NullString
	var headOfHouseSQL sql.NullString
	if headOfHouse != nil {
		headOfHouseSQL = sql.NullString{String: *headOfHouse, Valid: true}
	}

	// Generate a unique ID for the house
	houseID := fmt.Sprintf("house-%s", strings.ToLower(strings.ReplaceAll(name, " ", "-")))

	// Create the house in the database
	house, err := r.Queries.CreateHouse(ctx, db.CreateHouseParams{
		ID:          houseID,
		FirstName:   firstName,
		LastName:    lastName,
		HeadOfHouse: headOfHouseSQL,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create house: %v", err)
	}

	// Convert to GraphQL model
	return &model.House{
		ID:          house.ID,
		Name:        house.FirstName,
		HeadOfHouse: &house.HeadOfHouse.String,
	}, nil
}

// CreateStudent implements MutationResolver.
func (r *mutationResolver) CreateStudent(ctx context.Context, name string, age int32, houseID string) (*model.Student, error) {
	// Split name into first name and last name (assuming space separated)
	names := strings.Split(name, " ")
	firstName := names[0]
	lastName := ""
	if len(names) > 1 {
		lastName = strings.Join(names[1:], " ")
	} else {
		lastName = "Student"
	}

	// Generate a unique student ID
	studentID := fmt.Sprintf("stu-%s", strings.ToLower(strings.ReplaceAll(name, " ", "-")))

	// Create the student in the database
	student, err := r.Queries.CreateStudent(ctx, db.CreateStudentParams{
		ID:        studentID,
		FirstName: firstName,
		LastName:  lastName,
		Age:       sql.NullInt32{Int32: age, Valid: true},
		HouseID:   sql.NullString{String: houseID, Valid: true},
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create student: %v", err)
	}

	// Convert to GraphQL model
	agePtr := student.Age.Int32
	return &model.Student{
		ID:   student.ID,
		Name: student.FirstName + " " + student.LastName,
		Age:  &agePtr,
	}, nil
}

// Houses implements QueryResolver.
func (r *queryResolver) Houses(ctx context.Context) ([]*model.House, error) {
	// Get all houses from database
	houses, err := r.Queries.GetAllHouses(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get houses: %v", err)
	}

	// Convert to GraphQL model
	var result []*model.House
	for _, h := range houses {
		house := &model.House{
			ID:   h.ID,
			Name: h.FirstName + " " + h.LastName,
		}
		if h.HeadOfHouse.Valid {
			house.HeadOfHouse = &h.HeadOfHouse.String
		}
		result = append(result, house)
	}

	return result, nil
}

// StudentsByHouse implements QueryResolver.
func (r *queryResolver) StudentsByHouse(ctx context.Context, houseID string) ([]*model.Student, error) {
	// Get students from database for the given house
	students, err := r.Queries.GetStudentsByHouse(ctx, sql.NullString{
		String: houseID,
		Valid:  true,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get students: %v", err)
	}

	// Convert to GraphQL model
	var result []*model.Student
	for _, s := range students {
		student := &model.Student{
			ID:   s.ID,
			Name: s.FirstName + " " + s.LastName,
		}
		if s.Age.Valid {
			age := s.Age.Int32
			student.Age = &age
		}
		result = append(result, student)
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
